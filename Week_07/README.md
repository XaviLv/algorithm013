# 学习笔记 / week 07

## 代码作业

- Trie：[单词搜索II](212_单词搜索II.py)
    - 优化1：不用每次都从 Trie root 搜索整个单词，因为 DFS 已经有了搜索的能力，只需要判断下一个节点是否在当前 trie树的子树，因此 DFS 传入 current node，也得益于此，无需实现和调用 search；
    - 优化2：如果一个单词已经证明存在与board中，下一次检索就不用再检索，因为board 只能够可能有多种走法组成这个单词。也就是说，这个待检索的单词库是动态变化的。如果单词库为空，则无需再继续检索。
    - 212.单词搜索II 时间复杂度：O(logN*m*n*4^k)，其中查找字符串是否存在于给定单词库中使用Trie树，将普通的O(N)优化为O(logN)；m、n分别为board的行列树，4 表示 4 连通，k 表示单词库中单词的平均长度。

- DP：[括号生成](22_括号生成.py)

    -  DP 找重复性（分治）、最优子结构（定义状态数组）、写状态方程
    求 i 个括号对，可以分解如下：
    先提取一对括号（），剩下 i-1 对括号，我们可以在预先提取的括号内放置 x 对括号，在它右边放置 y 对括号，显然：
    x + y == i-1，其中 x 从 0～i-1
    我们定义 dp[i] 为 i 对括号对所有可能有效组合


## 字典树（Trie）
典型应用：统计和排序大量的字符串，常被搜索引擎用于文本词频统计；
优点：最大限度地减少无谓字符串的比较，查询效率比哈希表高。

基本性质：
1. 节点本省不存储完整单词，但可以存储额外信息，比如字符串出现的次数。
2. 从根节点到某一节点路径上经过的字符连起来，为该节点对应的字符串；
3. 每个节点的所有子节点路径代表的字符都不同。

核心思想：空间换时间，利用字符串的公共前缀来降低查询时间，提高效率。

## 并查集（UnionFind）
```python

class UnionFind:
    def __init__(self):
        self.parents = []

    def parent(self, i):
        root = i
        while root != self.parents[root]:
            root = self.parents[root]
        # 路径压缩
        while i != self.parents[i]:
            self.parents[i], i = root, self.parents[i]

    def union(self, i, j):
        p0 = self.parent(i)
        p1 = self.parent(j)
        self.parents[p0] = p1

```


## 高级搜索

### 剪枝

- 定义： 在状态树搜索时，如果遇到已经处理过的分支，就把它暂存在缓存里，整个分支就可以剪掉，无需再手动计算。有时分支是次优的，也可以剪掉。

- 剪枝的说法是延续状态 **树** 的引申义。

- 应用：Fibonacci问题、象棋、围棋、游戏AI。当问题的状态树非常复杂的时候，用传统的方法分析会导致搜索空间爆掉，近年可借助深度学习手段进行处理。比如AlphaGo，它也是在状态树里面进行更有效的评估，哪个分支更好，以及更有效地剪枝。

### 回溯

- 思想：分治 + 试错：尝试分步解决问题，当发现当前步骤不能解决问题，就取消上一步或上几步，并尝试其他走法。

- 回溯常用最简单的递归实现，最坏情况下时间复杂度退回到指数级。

### 基础树

- 如果一棵树是二叉树搜索树，那它的中序遍历是升序的。

- 二叉搜索树是指一棵空树，或者具有以下性质的树：1. 左子树上所有节点的值均小于根节点；2. 右子树上所有节点的值均大于根节点；3. 左右子树也分别是二叉搜索树（重复性）。

- 二叉搜索树的时间复杂度：O(logN)，优化了链表O(N)的时间复杂度。注意这里的N是所有节点数，logN相当于树的高度。极端情况下，二叉搜索树会变成一个链表，导致时间复杂度退回到O(N)，保证性能的关键：根节点的左右子树节点平衡，且左右子树本身都尽量平衡。—— 平衡二叉树。

- 平衡二叉树：AVL、Red-Black、B+、2-3、Splay、Treap ……




### AVL

- 命名：发明者 G.M.Adelson-Velsky 和 Evgenii Landis

- Ballance Factor（平衡因子）：左子树高度减去右子树**高度**（有时相反），始终保证任何一个节点的平衡因子在 {-1, 0, 1}.

- 为什么用平衡因子？因为树的查询时间复杂度是与树的高度正相关的，而平衡因子就是基于树的高度定义。

- 通过旋转操作进行平衡：

    1. 左左子树：左旋
    2. 右右子树：右旋
    3. 左右子树：左右旋
    4. 右左子树：右左旋

- 缺点：节点需要存储额外信息，且调整次数频繁。因此引入*近似平衡二叉树*，即每次不需要非常严格的平衡。

### 红黑树

- 定义：红黑树是一种近似平衡二叉树，它能保证任何一个节点的左右子树的高度差小于 2 倍。

- 性质（以下 5 个性质可以保证上面的定义成立）

    1. 每个节点要么是红色，要么是黑色；
    2. 根节点是黑色的；
    3. 每个叶节点是黑色的；
    4. 不能有相邻的两个红色节点；
    5. 从任意节点到每个叶子节点的所有路径都包含相同数量的黑色节点。

- AVL vs. Red-Black Tree

    1. lookups：AVL比红黑树更（严格）平衡，所以查找效率更高；
    2. insertion/delete：红黑树提供更快的查找和删除操作，因为近似平衡导致更少的插入删除频率；
    3. storage：AVL每个节点需要一个 integer 保存更多的信息，如平衡因子或高度，而红黑树只需要一个 bit 保存 red or black；
    4. application：红黑树多用于语言的库中，如map、multimap、multisetin C++，而AVL多用于数据库以提供更高的查找效率。

